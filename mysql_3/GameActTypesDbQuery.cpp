/*
 * @file    GameActTypesDbQuery.cpp
 * @author  Piotr Gregor <piotrek.gregor gmail com>
 * @brief   Concrete query: fetch/extract all the log lines for a date time value passed as a string parameter and a given AccountID (passed as string parameter as well). Log lines will be returned a single string having them separated by ";" character. The log lines must be generated by replacing the place-holders in GameActionsTypes.GameActionLogText with the "paramaters" read from GameActionsLog.GameActionParameters.
 */


#include <map>
#include <vector>


#include "Utility.h"
#include "GameActTypesDbQuery.h"


CGameActTypesDbQuery::CGameActTypesDbQuery(MYSQL *con) : con_(con)
{
    if (con == NULL)
    {
        throw CGameActTypesDbQueryInitException();
    }
}

std::string CGameActTypesDbQuery::getLogText(const std::string& typeId)
{
    std::string result, cmd;
    MYSQL_RES *mysql_result;
    std::stringstream ss;

    cmd = "SELECT GameActionLogText FROM GameActionsTypes WHERE GameActionTypeID=" + typeId;

    if (mysql_query(con_, cmd.c_str()))
    {
        ss << "Database command execution failed with error [" << mysql_error(con_) <<  "]";
        throw CGameActTypesDbQueryExecuteQueryException(ss.str().c_str());
    }
    
    mysql_result = mysql_store_result(con_);
    if (mysql_result == NULL)
    {
        ss << "Database command execution failed with error [" << mysql_error(con_) << "]";
        throw CGameActTypesDbQueryExecuteQueryException(ss.str().c_str());
    }

    MYSQL_ROW row;
    row = mysql_fetch_row(mysql_result);
    result = (row[0] ? row[0] : "");

    mysql_free_result(mysql_result);
    Utility::rtrim(result);
    return result;
}

std::string CGameActTypesDbQuery::executeQuery(const std::string& dt, const std::string& accountId, const std::string& logMark, const std::string& paramMark, const std::string& separator)
{
    std::string typeId, parameters, logText, mounted, result, cmd;
    MYSQL_RES *mysql_result;
    std::stringstream ss;
    std::multimap<std::string, std::string> typeIdParamsMap; /* key: typeId, value: parameters */
    std::map<std::string, std::string> logTextMap;

    /* get all gameActionTypeID and GameActionParameters for given AccountID and GameActiondateTime */
    cmd = "SELECT GameActionTypeID, GameActionParameters FROM GameActionsLog WHERE (AccountID=" 
        + accountId + ") AND (GameActionDateTime  >='" + dt + "' AND GameActionDateTime <= '" + dt + "')";

    if (mysql_query(con_, cmd.c_str()))
    {
        ss << "Database command execution failed with error [" << mysql_error(con_) <<  "]";
        throw CGameActTypesDbQueryExecuteQueryException(ss.str().c_str());
    }
    
    mysql_result = mysql_store_result(con_);
    if (mysql_result == NULL)
    {
        ss << "Database command execution failed with error [" << mysql_error(con_) << "]";
        throw CGameActTypesDbQueryExecuteQueryException(ss.str().c_str());
    }

    /* process the rows, fetch log text if not present in hashtable */
    MYSQL_ROW row;
    while ((row = mysql_fetch_row(mysql_result))) 
    {
        typeId = (row[0] ? row[0] : "");
        parameters = (row[1] ? row[1] : "");
        typeIdParamsMap.insert(std::pair<std::string, std::string>(typeId, parameters));
    }
    mysql_free_result(mysql_result);

    /* iterate all buckets and get GameActionlogText for all GameActionTypeIDs,
     * but make only single database query for each unique GameActionTypeID as we iterate buckets
     * hashed */
    for (auto it = typeIdParamsMap.begin(); it != typeIdParamsMap.end(); it = typeIdParamsMap.upper_bound(it->first))
    {
        typeId = it->first;
        logText = getLogText(typeId); /* get log text */
        auto range = typeIdParamsMap.equal_range(typeId);
        for (auto it2 = range.first; it2 != range.second; ++it2)
        {
            if (it2->first != typeId) {
                typeId = it2->first;
                logText = getLogText(typeId); /* collision, fetch new log text from database */
            }
            if ((it2->second).find(paramMark) > 0)
            {
                (it2->second) = std::string(paramMark).append(it2->second);
            }
            mounted = Utility::mountAll(logText, it2->second, logMark, paramMark);
            result += mounted + separator;
        }
    }

    return result;
}
